算法思想
选择排序是一种简单直观的排序算法，其核心思想是通过不断选择未排序序列中的最小（或最大）元素，将其与未排序序列的起始位置交换，从而逐步构建有序序列。该过程分为两个区间：已排序区间（初始为空）和未排序区间（初始为整个数组） 。
def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        min_index = i  # 假设当前位置为最小值
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j  # 更新最小值的索引
        # 将最小值交换到已排序区间的末尾
        if i != min_index:
            arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr
外层循环（i从0到n-2）：
每次循环确定已排序区间的末尾位置（即i），初始时假设当前元素是最小值。
内层循环（j从i+1到n-1）：
遍历未排序区间，找到最小元素的索引min_index 
交换操作：
如果当前元素（i位置）不是最小值，则将最小值交换到i位置，扩展已排序区间 
示例流程（数组[5, 3, 8, 1]）：

第一次循环：找到最小值1，与5交换 → [1, 3, 8, 5]
第二次循环：找到3（已是最小），无需交换 → [1, 3, 8, 5]
第三次循环：找到5，与8交换 → [1, 3, 5, 8]
时间复杂度分析
比较次数： 每次外层循环需要比较(n-1)+(n-2)+…+1 = n(n-1)/2次 → O(n²) 。
交换次数： 最多交换n-1次（每次外层循环交换一次），最少交换0次（数组已有序）→ O(n)。
总体时间复杂度： 最好、最坏、平均时间复杂度均为O(n²)，因为无论数据是否有序，都需要遍历未排序区间找最小值 。
空间复杂度
O(1) 

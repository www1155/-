算法解释
插入排序是一种基于比较的简单排序算法，其核心思想是将未排序序列中的元素逐个插入到已排序序列的正确位置，类似于整理扑克牌的过程 
具体步骤如下：
初始状态：假设第一个元素为已排序序列，其余为未排序序列。
迭代插入：从未排序序列中取出元素，与已排序序列从后向前比较，找到合适位置后插入。
重复操作：直到所有元素均被插入到已排序序列中，排序完成。
该算法具有稳定性（相同元素的相对顺序不变）和原地性（无需额外存储空间） 
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]  # 将大于key的元素右移
            j -= 1
        arr[j + 1] = key  # 插入key到正确位置
    return arr
外层循环：从第二个元素开始遍历未排序序列（i从1开始）。
内层循环：向前比较已排序元素，若当前元素比key大则右移，直到找到插入位置。
插入操作：将key放入正确位置，保证已排序区间扩展 。
代码执行流程
以数组[5, 2, 4, 6, 1]为例：
第一次循环（i=1）：
key=2，与5比较，5右移 → [2, 5, 4, 6, 1]。
第二次循环（i=2）：
key=4，与5比较后右移 → [2, 4, 5, 6, 1]。
第三次循环（i=3）：
key=6无需移动，直接插入 → [2, 4, 5, 6, 1]。
第四次循环（i=4）：
key=1依次与6,5,4,2比较并右移，插入最左侧 → [1, 2, 4, 5, 6]
  时间复杂度分析
插入排序的时间复杂度取决于输入数据的初始状态：
最好情况（已排序数组）：仅需遍历一次，比较次数为n-1 → O(n) 
最坏情况（逆序数组）：需比较和移动1+2+...+(n-1)=n(n-1)/2次 → O(n²) 
平均情况（随机数组）：平均需要约n²/4次操作 → O(n²) 
5. 空间复杂度
 O(1) 

